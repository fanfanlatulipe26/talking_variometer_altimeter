## talking_variometer_altimeter
### A Poor Man’s simple and inexpensive Arduino-based RC sailplane talking variometer and altimeter

This project is built around Rolf R Bakke’s project of a [DIY simple and inexpensive Arduino-based sailplane variomete](<https://www.rcgroups.com/forums/showthread.php?1749208-DIY-simple-and-inexpensive-Arduino-based-sailplane-variometer>).  
For the fun, a “voice output” was added and the height of the model is spoken on demand.  

Main features:  
- Standalone system: it doesn’t rely on some telemetry channel offered by RC equipments but provides its own downlink transmitter and receiver in the 2.4 MHz band.
- Announce altitude increases with a specified step
- Announce on demand max / current altitude 
- Setup menu
- Choice of unit meters / feet
- Language for voice output easily customizable
- Built with inexpensive modules easily available

The system register the highest altitude reached during the current flight and can announce numbers up to 10999, positive or negative. (Hope that you are simply at the top of the slope if announced altitude is negative …)   

The transmitter and the receiver use only on one channel in the 2.4 GHz band.
If need be, you can change this channel in the transmitter and receiver source code. See at the beginning of source code the line

```
#define channelVario 0x50 
```

## The transmitter

**Bill of material:**

- Arduino Pro Mini 5v 16Mhz
- Module GY-63 MS5611 barometric pressure sensor
- Module NRF24L01 with PA+LNA (E01-ML01DP5)
- MCP1700 3.3v voltage regulator
- 2 capacitors 100µF
- RC cable with servo type plug. 
 <img src="/images/emetteur_vario.jpg"  width="800">
<img src="/images/nRF24L01.jpg" width="300">
This NRF24L01(E01-ML01DP5) module has the same size as the Arduino Pro Mini. If the SMA connector is too bulky it can be removed and the antenna replaced by a simple wire.  <br>
During the realization / wiring it may be wise to let at least the I2C SDA/SCL pins, as well as VCC / GND easily available for future development (airspeed sensor for example).  <br>
The transmitter is powered directly from the RC equipment, in 5v, through for example a spare servo plug on the receiver.

## The receiver / ground station

**Bill of material:**

- Arduino Pro Mini 3.3v 8Mhz
- Module NRF24L01 (optional: with PA+LNA E01-ML01DP5 )
- DFPlayer Mini MP3 reader
- MCP1700 3.3v voltage regulator
- 1 capacitor 100µF
- Small speaker 8Ω
- Passive buzzer 12x8mm
- Lipo battery 1s 120ma as a minimum
- Lipo charge / discharge management module TP4056
- Switch 
 <img src="/images/recepteur_vario.jpg"  width="800">
<img src="/images/chargeur.JPG" width="300">
<img src="/images/buzzer.JPG" width="300">
Don’t forget to adapt the charge current in the TP4056 module to the lipo you use ([see for example this document](https://www.best-microcontroller-projects.com/tp4056.html)). As delivered the module is usually set up for 1000ma battery.

## Using the variometer / altimeter

At power on, the system announces its current configuration and waits for a link with the transceiver. The current altitude is registered and the bip-bip of the variometer starts (if activated). Each time the current altitude of the model increments by a configurable step, the gain in altitude is announced (if activated).


### Setup menu. Buttons handling


The receiver in ground station features 2 push buttons used for managing the volume and the setup menu: buttonUp and buttonDown. 

The setup menu allows to control: 
- Activation / deactivation of the variometer
- Activation / deactivation of the altimeter
- Choice of the unit for altitude: meters or feet
- Choice of the step for altitude announcement
- Volume management for the messages

The configuration is saved and will be retrieved at next power up. 

When in normal mode:   
- A click on any button will increment/decrement the volume of the buzzer used for the variometer.
- Pressing both buttons 1 second will announce the current altitude and the maximum altitude since power on.
- Long push on any button will enter the setting mode. 

When in setting mode:   
The system will announce the menu entry and the associated parameter value. 
- short push on a button:
  - if the current entry is “Exit the setting menu”:  Exit setting mode and return to normal mode
  - For other entries:  increment or decrement a parameter value, or toggle the value. The system will announce the new value 
- Long push on a button: register le current value and pass to the next/ previous entry in the menu.

## Development requirements:  

- Arduino IDE
- RF24 library by TMRH20 installed with Arduino IDE library manager.
- toneAC by Tim Eckel installed with Arduino IDE library manager.
- Button library by t3db0t installed from <https://github.com/t3db0t/Button>
- Other libraries used by the project come with the IDE install. 

## Building the SD card

Voice output is generated by the DFPlayer module that includes a micro SD memory card slot with mp3 files.  
As delivered, the package already includes the files for English, French, Italian and Spanish but it is very easy to generate the files for a new language as we will see latter.   
The set of file for a specific language uses around 12Mb.  
Each directory for a language contains an mp3 folder, with subfolders 01 to 06 containing themselves the mp3 files. These subfolders must be copied at the root of the SD card.   
In order to optimize the response time of the DFPlayer modules it is better to use a newly formatted card and make the copy one folder after the other, in the order 00 to 06, just to be sure that folder 00 is physically copied first on the SD card, 01 the second etc..  (In Windows, it is impossible to control the order of the copy in a multiple select/drag/drop scenario) 

## Customizing the language.

With the help of **gTTS** (*Google Text-to-Speech*), a Python library and CLI tool to interface with Google Translate's text-to-speech API we generate spoken MP3 files that are then copied on the micro SD card.  (More info here <http://gtts.readthedocs.org/>)

2 kinds of files are generated:

- files for numbers
  - one MP3 file for each number from 0 to 999 stored in folders names 01, 02, 03, 04
  - ten MP3 files for the thousand 1000 to 10000 stored in folder 05
- A set of files for menu management. and announces  stored in folder 06

Software environment

You must install **Python** on your system as well as gTTS and eyeD3 libraries.
```
\>pip install gTTS

\> pip install eyeD3
```
Customization:

In a new working directory, make a copy of file one of the delivered [messages.txt](english/messages.txt) file and edit it.  
Each line of the file is composed of 3 field separated by “;”.   
Don’t change the first line of the file nor the first field (a file number) of each line.  
Translate every second field (Google Translate is my friend …).  
The third field is just a comment and ignored by the process.
```
Example: 		8;Altitude announced in; choice of meters or feet
```
Make a copy of Python script [generate_mp3.py](english/generate_mp3.py) and edit it (a simple text editor is OK …)   
Only one line must be change to customize the language:

langage = 'en'     # change this line for support of a new language.

The list of supported languages is available [here](list_of_languages.txt) (more than 50)

In Windows, start a PowerShell and from the newly created working directory run your customized script generate\_mp3.py

`	`>cd “path to my\_new\_dir”

`	`>python generate\_mp3.py

The Python script generates an mp3 folder, with subfolders 01 to 07 containing the mp3 files that must be copied at the root of the SD card. (See above link ….)

Check mp3 files, mainly in directory “07”: pronunciation may be incorrect if the text file contains accented characters. Adapt/remove theses characters and regenerate the mp3 files. (Information about character set used/supported by gtts is welcome …)



